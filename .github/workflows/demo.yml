name: Demo

on:
  workflow_dispatch:
  push:

jobs:
  demo:
    name: Docker Compose demo
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Install AWS CLI
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip
          pip3 install --upgrade --user awscli
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Start stack
        run: docker compose up --build -d

      - name: Wait for services to initialize
        run: sleep 15

      - name: Wait for Schema Registry
        shell: bash
        run: |
          set -euo pipefail
          for i in {1..30}; do
            code="$(curl -s -o /dev/null -w '%{http_code}' http://localhost:8081/subjects 2>/dev/null)" || code="000"
            code="${code:-000}"
            if [ "$code" = "200" ]; then
              echo "Schema Registry is ready"
              exit 0
            fi
            echo "Waiting for Schema Registry (HTTP $code)"
            sleep 2
          done
          echo "Schema Registry did not become ready in time"
          exit 1

      - name: Wait for API health
        shell: bash
        run: |
          set -euo pipefail
          for i in {1..60}; do
            body="$(curl -s http://localhost:8080/actuator/health || true)"
            if echo "$body" | grep -q '"status":"UP"'; then
              echo "API is healthy"
              exit 0
            fi
            echo "Waiting for API health endpoint"
            sleep 2
          done
          echo "API did not become healthy in time"
          exit 1

      - name: Warm-up single event (verify Kafka connectivity)
        shell: bash
        run: |
          set -euo pipefail
          code="$(curl -s -o /tmp/publish-warmup.json -w '%{http_code}' -X POST http://localhost:8080/events \
            -H "Content-Type: application/json" \
            -d '{"id":"evt-warmup","type":"user.created","payload":"{}"}')"
          if [ "$code" -lt 200 ] || [ "$code" -ge 300 ]; then
            echo "Warm-up failed (HTTP $code)"
            cat /tmp/publish-warmup.json || true
            docker compose logs api --tail 50
            exit 1
          fi
          echo "Warm-up succeeded (HTTP $code)"

      - name: Publish test events (v1 OCF)
        shell: bash
        run: |
          set -euo pipefail
          tmpfile="$(mktemp)"
          python3 - <<'PY' > "$tmpfile"
          import json
          for i in range(1, 51):
              payload = json.dumps({"userId": f"{i:03d}"})
              print(json.dumps({
                  "id": f"evt-{i:03d}",
                  "type": "user.created",
                  "payload": payload,
              }))
          PY
          code="$(curl -s -o /tmp/publish-response.json -w '%{http_code}' -X POST http://localhost:8080/events/stream \
            -H "Content-Type: application/x-ndjson" \
            -H "x-ack-mode: wait" \
            --data-binary @"$tmpfile")"
          if [ "$code" -lt 200 ] || [ "$code" -ge 300 ]; then
            echo "Publish v1 failed (HTTP $code)"
            cat /tmp/publish-response.json || true
            docker compose logs api --tail 50
            exit 1
          fi

      - name: Publish test events (v2 Schema Registry)
        shell: bash
        run: |
          set -euo pipefail
          tmpfile="$(mktemp)"
          python3 - <<'PY' > "$tmpfile"
          import json
          for i in range(51, 101):
              payload = json.dumps({"userId": f"{i:03d}"})
              print(json.dumps({
                  "id": f"evt-sr-{i:03d}",
                  "type": "user.created",
                  "payload": payload,
              }))
          PY
          code="$(curl -s -o /tmp/publish-response.json -w '%{http_code}' -X POST http://localhost:8080/events/v2/stream \
            -H "Content-Type: application/x-ndjson" \
            -H "x-ack-mode: wait" \
            --data-binary @"$tmpfile")"
          if [ "$code" -lt 200 ] || [ "$code" -ge 300 ]; then
            echo "Publish v2 failed (HTTP $code)"
            cat /tmp/publish-response.json || true
            docker compose logs api --tail 50
            exit 1
          fi

      - name: Wait for S3 sink flush
        run: sleep 15

      - name: Dump stack logs on failure
        if: failure()
        run: |
          docker compose ps
          docker compose logs --no-color api
          docker compose logs --no-color s3-sink
          docker compose logs --no-color schema-registry
          docker compose logs --no-color kafka
          docker compose logs --no-color localstack

      - name: Verify Parquet output in LocalStack
        shell: bash
        env:
          AWS_ACCESS_KEY_ID: test
          AWS_SECRET_ACCESS_KEY: test
          AWS_DEFAULT_REGION: us-east-1
        run: |
          set -euo pipefail
          echo "Buckets:"
          aws --endpoint-url=http://localhost:4566 s3 ls
          echo "Listing events prefix:"
          aws --endpoint-url=http://localhost:4566 s3 ls s3://demo-parquet-bucket/events/ || true
          aws --endpoint-url=http://localhost:4566 s3api list-objects-v2 --bucket demo-parquet-bucket --prefix events/ --max-keys 50 || true

          topic_prefix=""
          date_prefix=""
          for i in {1..30}; do
            topic_prefix="$(aws --endpoint-url=http://localhost:4566 s3 ls s3://demo-parquet-bucket/events/ 2>/dev/null | awk '/PRE topic=/{print $2}' | head -n1 || true)"
            if [ -n "$topic_prefix" ]; then
              break
            fi
            echo "Waiting for topic prefix to appear in S3 (attempt $i/30)"
            sleep 2
          done
          if [ -z "$topic_prefix" ]; then
            echo "No topic prefix found in bucket"
            aws --endpoint-url=http://localhost:4566 s3api list-objects-v2 --bucket demo-parquet-bucket --prefix events/ --max-keys 50 || true
            docker compose logs s3-sink --tail 50
            exit 1
          fi

          echo "Listing topic prefix: ${topic_prefix}"
          aws --endpoint-url=http://localhost:4566 s3 ls "s3://demo-parquet-bucket/events/${topic_prefix}"

          for i in {1..30}; do
            date_prefix="$(aws --endpoint-url=http://localhost:4566 s3 ls "s3://demo-parquet-bucket/events/${topic_prefix}" | awk '/PRE date=/{print $2}' | head -n1)"
            if [ -n "$date_prefix" ]; then
              break
            fi
            echo "Waiting for date prefix to appear for ${topic_prefix}"
            sleep 2
          done
          if [ -z "$date_prefix" ]; then
            echo "No date prefix found for ${topic_prefix}"
            aws --endpoint-url=http://localhost:4566 s3api list-objects-v2 --bucket demo-parquet-bucket --prefix "events/${topic_prefix}" --max-keys 50 || true
            exit 1
          fi

          echo "Listing date prefix: ${date_prefix}"
          aws --endpoint-url=http://localhost:4566 s3 ls "s3://demo-parquet-bucket/events/${topic_prefix}${date_prefix}"

          echo "Verifying events-schema-registry prefix:"
          sr_prefix=""
          for i in {1..30}; do
            sr_prefix="$(aws --endpoint-url=http://localhost:4566 s3 ls s3://demo-parquet-bucket/events-schema-registry/ 2>/dev/null | awk '/PRE topic=/{print $2}' | head -n1)"
            if [ -n "$sr_prefix" ]; then
              echo "Schema Registry topic prefix: ${sr_prefix}"
              aws --endpoint-url=http://localhost:4566 s3 ls "s3://demo-parquet-bucket/events-schema-registry/${sr_prefix}"
              break
            fi
            echo "Waiting for events-schema-registry prefix"
            sleep 2
          done
          if [ -z "$sr_prefix" ]; then
            echo "No events-schema-registry prefix found in bucket"
            aws --endpoint-url=http://localhost:4566 s3api list-objects-v2 --bucket demo-parquet-bucket --prefix events-schema-registry/ --max-keys 50 || true
            docker compose logs s3-sink --tail 50
            exit 1
          fi

      - name: Tear down stack
        if: always()
        run: docker compose down -v
